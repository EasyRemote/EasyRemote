# GEO-SCOPE Release Workflow
# è‡ªåŠ¨æ„å»ºå¤šå¹³å° Tauri åº”ç”¨å¹¶å‘å¸ƒåˆ° Release æœåŠ¡å™¨
#
# è§¦å‘é€»è¾‘:
#   PR merged to product + ä»£ç å˜æ›´ â†’ è‡ªåŠ¨æ„å»ºå‘å¸ƒ
#   push tag (v*)                   â†’ ä½¿ç”¨ tag ç‰ˆæœ¬å·
#   workflow_dispatch               â†’ æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬
#
# ç‰ˆæœ¬å·è§„åˆ™:
#   - è‡ªåŠ¨è®¡ç®—: {tagæ•°é‡}.{å¼€å‘å¤©æ•°}.{å½“å¤©commitåºå·}
#   - æ‰‹åŠ¨ tag: v1.0.0, v1.0.0-beta.1, v1.0.0-rc.1

name: Release

on:
  pull_request_target:
    types: [closed]
    branches: [product]

  push:
    tags: ['v*']

  workflow_dispatch:
    inputs:
      version:
        description: 'ç‰ˆæœ¬å· (ç•™ç©ºåˆ™è‡ªåŠ¨è®¡ç®—)'
        default: ''
      notes_zh:
        description: 'ä¸­æ–‡æ›´æ–°æ—¥å¿—'
        default: ''
      notes_en:
        description: 'è‹±æ–‡æ›´æ–°æ—¥å¿—'
        default: ''
      is_critical:
        description: 'æ˜¯å¦ä¸ºå…³é”®æ›´æ–°'
        type: boolean
        default: false
      is_prerelease:
        description: 'æ˜¯å¦ä¸ºé¢„å‘å¸ƒç‰ˆæœ¬ (Beta)'
        type: boolean
        default: false

env:
  RELEASE_SERVER_URL: ${{ secrets.RELEASE_SERVER_URL || 'https://releases.geo-scope.ai' }}

jobs:
  # æ£€æŸ¥æ˜¯å¦éœ€è¦æ„å»º
  check:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_run }}
      is_release: ${{ steps.check.outputs.is_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check changes
        id: check
        uses: ./.github/actions/check-changes
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          check_paths: 'Backend,Frontend'

  # =============================================================================
  # å‡†å¤‡é˜¶æ®µ - è§£æç‰ˆæœ¬å·å’Œåˆ›å»ºå‘å¸ƒ
  # =============================================================================
  prepare:
    needs: check
    if: needs.check.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag_name: ${{ steps.get_version.outputs.tag_name }}
      is_prerelease: ${{ steps.get_version.outputs.is_prerelease }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && 'product' || github.ref }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get version and detect prerelease
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # æ‰‹åŠ¨è§¦å‘ï¼šä½¿ç”¨æŒ‡å®šç‰ˆæœ¬æˆ–è‡ªåŠ¨è®¡ç®—
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              VERSION=$(node scripts/version.js)
            fi
            IS_PRERELEASE="${{ github.event.inputs.is_prerelease }}"
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            # ä» tag ä¸­æå–ç‰ˆæœ¬å· (å»æ‰ v å‰ç¼€)
            VERSION="${GITHUB_REF#refs/tags/v}"

            # è‡ªåŠ¨æ£€æµ‹é¢„å‘å¸ƒç‰ˆæœ¬ (alpha, beta, rc, dev, pre)
            if [[ "$VERSION" =~ -(alpha|beta|rc|dev|pre) ]]; then
              IS_PRERELEASE="true"
              echo "ğŸ§ª Detected prerelease version from tag"
            else
              IS_PRERELEASE="false"
              echo "ğŸ“¦ Detected stable version from tag"
            fi
          else
            # è‡ªåŠ¨è®¡ç®—ç‰ˆæœ¬å·: {tagæ•°é‡}.{å¼€å‘å¤©æ•°}.{å½“å¤©commitåºå·}
            VERSION=$(node scripts/version.js)
            IS_PRERELEASE="false"
            echo "ğŸ”¢ Auto-calculated version"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=v$VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Version: $VERSION (prerelease: $IS_PRERELEASE)"

      - name: Get commits for changelog
        id: get_commits
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # ä½¿ç”¨ jq å®‰å…¨åœ°æ„å»º JSONï¼Œé¿å…ç‰¹æ®Šå­—ç¬¦å¯¼è‡´çš„ JSON æ ¼å¼é”™è¯¯
          build_commits_json() {
            local range="$1"
            local limit="$2"

            if [ -n "$range" ]; then
              git log $range --pretty=format:'%h%x00%s' $limit | \
                jq -Rs 'split("\n") | map(select(length > 0) | split("\u0000") | {hash: .[0], message: .[1]})'
            else
              git log --pretty=format:'%h%x00%s' $limit | \
                jq -Rs 'split("\n") | map(select(length > 0) | split("\u0000") | {hash: .[0], message: .[1]})'
            fi
          }

          # æ ¹æ®è§¦å‘æ–¹å¼è·å– commits
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            # Tag è§¦å‘ï¼šè·å–è‡ªä¸Šä¸€ä¸ª tag ä»¥æ¥çš„æ‰€æœ‰ commits
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              COMMITS_JSON=$(build_commits_json "$PREV_TAG..HEAD" "")
            else
              COMMITS_JSON=$(build_commits_json "" "-10")
            fi
          elif [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            # Push è§¦å‘ï¼šåªè·å–æœ¬æ¬¡ push æ–°å¢çš„ commits (before..after)
            echo "ğŸ“ Getting commits from ${{ github.event.before }} to ${{ github.sha }}"
            COMMITS_JSON=$(build_commits_json "${{ github.event.before }}..${{ github.sha }}" "")

            # å¦‚æœæ²¡æœ‰æ–° commitsï¼ˆå¯èƒ½æ˜¯ force pushï¼‰ï¼Œè·å–æœ€æ–°çš„ä¸€ä¸ª
            if [ "$COMMITS_JSON" = "[]" ] || [ -z "$COMMITS_JSON" ]; then
              echo "âš ï¸ No new commits found, using HEAD"
              COMMITS_JSON=$(build_commits_json "" "-1")
            fi
          else
            # Fallbackï¼šæ‰‹åŠ¨è§¦å‘æˆ–é¦–æ¬¡ pushï¼Œè·å–æœ€æ–°çš„ commit
            echo "ğŸ“ Manual trigger or first push, getting latest commit"
            COMMITS_JSON=$(build_commits_json "" "-1")
          fi

          # ä½¿ç”¨ heredoc å®‰å…¨åœ°è¾“å‡ºå¤šè¡Œ JSON
          {
            echo "commits<<COMMITS_EOF"
            echo "$COMMITS_JSON"
            echo "COMMITS_EOF"
          } >> $GITHUB_OUTPUT
          echo "ğŸ“ Found commits: $COMMITS_JSON"

      - name: Generate changelog via AI Summary
        id: ai_summary
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TODAY=$(date -u +"%Y-%m-%d")

          # è¯»å– commits JSON (ä½¿ç”¨ jq -c å‹ç¼©å¹¶éªŒè¯ JSON æ ¼å¼)
          COMMITS='${{ steps.get_commits.outputs.commits }}'

          # éªŒè¯å¹¶å‹ç¼© JSON (ç§»é™¤ç©ºç™½ä½†ä¿æŒç»“æ„)
          if ! COMMITS=$(echo "$COMMITS" | jq -c '.' 2>/dev/null); then
            echo "âš ï¸ Invalid commits JSON, using empty array"
            COMMITS='[]'
          fi

          echo "ğŸ¤– Generating AI-powered changelog summary..."
          echo "ğŸ“¦ Version: $VERSION"
          echo "ğŸ“… Date: $TODAY"
          echo "ğŸ“ Commits: $COMMITS"

          # è°ƒç”¨ Summary API ç”Ÿæˆæ›´æ–°æ—¥å¿—
          echo "ğŸ”— Calling: ${{ env.RELEASE_SERVER_URL }}/api/summary/generate"
          echo "ğŸ”‘ API Key configured: ${{ secrets.RELEASE_API_KEY != '' }}"

          # ä½¿ç”¨ jq å®‰å…¨æ„å»ºè¯·æ±‚ JSON
          REQUEST_BODY=$(jq -n \
            --arg version "$VERSION" \
            --argjson commits "$COMMITS" \
            --arg date "$TODAY" \
            --arg author "silan.tech" \
            '{version: $version, commits: $commits, date: $date, author_username: $author, save_to_db: true}')

          HTTP_RESPONSE=$(curl -s -L --post302 --post301 -w "\n%{http_code}" -X POST "${{ env.RELEASE_SERVER_URL }}/api/summary/generate" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${{ secrets.RELEASE_API_KEY }}" \
            --connect-timeout 30 \
            --max-time 120 \
            -d "$REQUEST_BODY" 2>&1)

          HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n1)
          SUMMARY_RESPONSE=$(echo "$HTTP_RESPONSE" | sed '$d')

          echo "ğŸ“¡ HTTP Status: $HTTP_CODE"

          if [ -z "$SUMMARY_RESPONSE" ]; then
            echo "âš ï¸ Empty response from API"
            SUMMARY_RESPONSE='{"success": false, "error": "empty response"}'
          fi

          echo "Summary API response: $SUMMARY_RESPONSE"

          # æ£€æŸ¥æ˜¯å¦æˆåŠŸ
          SUCCESS=$(echo "$SUMMARY_RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "âœ… AI changelog generated and saved to database"
            NOTES_EN=$(echo "$SUMMARY_RESPONSE" | jq -r '.notes.en // "Release update"')
            NOTES_ZH=$(echo "$SUMMARY_RESPONSE" | jq -r '.notes.zh // "ç‰ˆæœ¬æ›´æ–°"')
            echo "notes_en=$NOTES_EN" >> $GITHUB_OUTPUT
            echo "notes_zh=$NOTES_ZH" >> $GITHUB_OUTPUT
            echo "ai_generated=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ AI summary failed, using default notes"
            echo "notes_en=Release $VERSION" >> $GITHUB_OUTPUT
            echo "notes_zh=å‘å¸ƒç‰ˆæœ¬ $VERSION" >> $GITHUB_OUTPUT
            echo "ai_generated=false" >> $GITHUB_OUTPUT
          fi

      - name: Create release on server (fallback)
        if: steps.ai_summary.outputs.ai_generated != 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          IS_PRERELEASE="${{ steps.get_version.outputs.is_prerelease }}"

          # è·å–æ›´æ–°æ—¥å¿—
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            NOTES_ZH="${{ github.event.inputs.notes_zh }}"
            NOTES_EN="${{ github.event.inputs.notes_en }}"
            IS_CRITICAL="${{ github.event.inputs.is_critical }}"
          else
            # ä½¿ç”¨ AI ç”Ÿæˆçš„å†…å®¹æˆ–é»˜è®¤å€¼
            NOTES_EN="${{ steps.ai_summary.outputs.notes_en }}"
            NOTES_ZH="${{ steps.ai_summary.outputs.notes_zh }}"
            IS_CRITICAL="false"
          fi

          # ä½¿ç”¨æ–°çš„å¤šè¯­è¨€ JSON æ ¼å¼
          NOTES_JSON=$(jq -n --arg zh "$NOTES_ZH" --arg en "$NOTES_EN" '{"zh": $zh, "en": $en}')

          # è°ƒç”¨ Release API åˆ›å»ºç‰ˆæœ¬ (å¦‚æœä¸å­˜åœ¨)
          curl -s -X POST "${{ env.RELEASE_SERVER_URL }}/api/releases" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_API_KEY }}" \
            -d "{
              \"version\": \"$VERSION\",
              \"notes\": $NOTES_JSON,
              \"is_critical\": $IS_CRITICAL,
              \"is_prerelease\": $IS_PRERELEASE,
              \"author\": {
                \"name\": \"GitHub Actions\",
                \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
              }
            }" || echo "Release may already exist, continuing..."

  # =============================================================================
  # æ„å»ºé˜¶æ®µ - å¤šå¹³å°å¹¶è¡Œæ„å»º
  # =============================================================================
  build:
    needs: [check, prepare]
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # =============================================================================
          # macOS æ„å»ºæš‚æ—¶ç¦ç”¨ - Apple å…¬è¯æœåŠ¡é—®é¢˜
          # TODO: è§£å†³å…¬è¯è¶…æ—¶é—®é¢˜åé‡æ–°å¯ç”¨
          # =============================================================================
          # # macOS Apple Silicon (ä½¿ç”¨ .app.tar.gz ç”¨äºæ›´æ–°å™¨ç­¾å)
          # - platform: macos-latest
          #   target: aarch64-apple-darwin
          #   os_name: darwin
          #   arch: aarch64
          #   ext: app.tar.gz
          #   bundle_dir: macos

          # # macOS Intel (ä½¿ç”¨ .app.tar.gz ç”¨äºæ›´æ–°å™¨ç­¾å)
          # - platform: macos-15-intel
          #   target: x86_64-apple-darwin
          #   os_name: darwin
          #   arch: x86_64
          #   ext: app.tar.gz
          #   bundle_dir: macos

          # Windows x64
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            os_name: windows
            arch: x86_64
            ext: msi
            bundle_dir: msi

          # Linux x64
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            os_name: linux
            arch: x86_64
            ext: AppImage
            bundle_dir: appimage

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: matrix.os_name == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libssl-dev

      - name: Install frontend dependencies
        working-directory: Frontend
        run: npm ci

      - name: Create frontend environment file
        working-directory: Frontend
        shell: bash
        run: |
          cat > .env.local << 'EOF'
          VITE_APP_MODE=release
          VITE_APP_VERSION=${{ needs.prepare.outputs.version }}
          VITE_API_URL_DEV=http://localhost:8000
          VITE_API_URL_PROD=https://geo-scope.ai
          BACKEND_DIRECTORY=/api
          VITE_RELEASE_URL_DEV=http://localhost:8001
          VITE_RELEASE_URL_PROD=https://releases.geo-scope.ai
          RELEASE_DIRECTORY=/api
          EOF
          echo "ğŸ“ Created .env.local with VITE_APP_MODE=release"

      # =============================================================================
      # macOS ä»£ç ç­¾åè®¾ç½®
      # =============================================================================
      - name: Import macOS signing certificate
        if: matrix.os_name == 'darwin'
        id: macos_cert
        timeout-minutes: 5
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # macOS æ„å»ºå¿…é¡»æœ‰è¯ä¹¦ï¼Œå¦åˆ™ç›´æ¥å¤±è´¥
          if [ -z "$MACOS_CERTIFICATE" ]; then
            echo "âŒ MACOS_CERTIFICATE is required for macOS builds"
            echo "configured=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "ğŸ” Importing macOS signing certificate..."

          # è§£ç è¯ä¹¦
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12

          # åˆ›å»ºä¸´æ—¶é’¥åŒ™ä¸²
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # ä¿å­˜é’¥åŒ™ä¸²å¯†ç ä¾›åç»­æ­¥éª¤ä½¿ç”¨
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # è®¾ç½®é’¥åŒ™ä¸²ä¸è‡ªåŠ¨é”å®š (é˜²æ­¢æ„å»ºè¿‡ç¨‹ä¸­é”å®šå¯¼è‡´å¡ä½)
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          # å¯¼å…¥è¯ä¹¦åˆ°é’¥åŒ™ä¸²
          security import certificate.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # è®¾ç½®åˆ†åŒºåˆ—è¡¨ä»¥å…è®¸ codesign è®¿é—® (æ— éœ€äº¤äº’)
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # æ·»åŠ åˆ°æœç´¢åˆ—è¡¨
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          # éªŒè¯è¯ä¹¦å¯¼å…¥
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # æ¸…ç†è¯ä¹¦æ–‡ä»¶
          rm -f certificate.p12

          echo "configured=true" >> $GITHUB_OUTPUT
          echo "âœ… Certificate imported successfully"

      # è°ƒè¯•ï¼šæ£€æŸ¥ç­¾å identity æ˜¯å¦å¯ç”¨
      - name: Debug signing identities (macOS)
        if: matrix.os_name == 'darwin'
        run: |
          echo "== Keychains in search list =="
          security list-keychains -d user

          echo ""
          echo "== Code signing identities (default search list) =="
          security find-identity -v -p codesigning || true

          echo ""
          echo "== Code signing identities (in build keychain) =="
          if [ -n "$KEYCHAIN_PATH" ]; then
            security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          fi

          echo ""
          echo "== Expected APPLE_SIGNING_IDENTITY =="
          echo "${{ secrets.APPLE_SIGNING_IDENTITY }}"

      - name: Update version in tauri.conf.json
        working-directory: Frontend
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "ğŸ“ Updating tauri.conf.json version to $VERSION"

          # ä½¿ç”¨ node æ›´æ–° JSON (è·¨å¹³å°å…¼å®¹)
          node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            config.version = '$VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('âœ… Version updated to:', config.version);
          "

      # åœ¨ macOS æ„å»ºå‰ç¡®ä¿é’¥åŒ™ä¸²å¯è®¿é—®
      - name: Prepare keychain for signing
        if: matrix.os_name == 'darwin'
        run: |
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "ğŸ”“ Ensuring keychain is unlocked and accessible..."
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" 2>/dev/null || true
            security set-keychain-settings -t 7200 -u "$KEYCHAIN_PATH" 2>/dev/null || true
            security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"') 2>/dev/null || true
            echo "âœ… Keychain prepared"
          fi

      - name: Build Tauri app
        working-directory: Frontend
        shell: bash
        timeout-minutes: 30
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS ä»£ç ç­¾åé…ç½® (Tauri ä¼šè‡ªåŠ¨ä½¿ç”¨è¿™äº›ç¯å¢ƒå˜é‡)
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # æ£€æŸ¥ç­¾åå¯†é’¥æ˜¯å¦å·²é…ç½®
          if [ -n "$TAURI_SIGNING_PRIVATE_KEY" ]; then
            echo "âœ… TAURI_SIGNING_PRIVATE_KEY is set (length: ${#TAURI_SIGNING_PRIVATE_KEY})"
          else
            echo "âŒ TAURI_SIGNING_PRIVATE_KEY is NOT set - signatures will not be generated!"
          fi

          # macOS ç­¾åæ£€æŸ¥å’Œé’¥åŒ™ä¸²è§£é”
          if [ "${{ matrix.os_name }}" = "darwin" ]; then
            # ç¡®ä¿é’¥åŒ™ä¸²åœ¨æ„å»ºå‰è§£é” (é˜²æ­¢é•¿æ—¶é—´æ„å»ºåè¢«é”å®š)
            if [ -n "$KEYCHAIN_PATH" ] && [ -n "$KEYCHAIN_PASSWORD" ]; then
              echo "ğŸ”“ Unlocking keychain before build..."
              security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
              # å»¶é•¿é”å®šè¶…æ—¶
              security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"
            fi

            if [ -n "$APPLE_SIGNING_IDENTITY" ]; then
              echo "âœ… APPLE_SIGNING_IDENTITY is set: $APPLE_SIGNING_IDENTITY"
            else
              echo "âš ï¸ APPLE_SIGNING_IDENTITY not set, looking for available identities..."
              security find-identity -v -p codesigning || true
            fi
          fi

          # æ ¼å¼åŒ–æ„å»ºæ—¥æœŸä¸º YYYY-MM-DD
          export BUILD_DATE=$(date -u +"%Y-%m-%d")
          echo "ğŸ“… Build date: $BUILD_DATE"
          npm run tauri build -- --target ${{ matrix.target }}

      # éªŒè¯ macOS ç­¾åæ˜¯å¦æˆåŠŸ
      - name: Verify macOS code signature
        if: matrix.os_name == 'darwin'
        run: |
          APP_PATH=$(find Frontend/src-tauri/target/${{ matrix.target }}/release/bundle/macos -name "*.app" -type d | head -1)

          if [ -z "$APP_PATH" ]; then
            echo "âŒ No .app bundle found"
            exit 1
          fi

          echo "ğŸ“¦ Verifying signature for: $APP_PATH"

          # æ£€æŸ¥ç­¾å
          echo "== codesign --verify =="
          codesign --verify --deep --strict --verbose=2 "$APP_PATH" 2>&1 || {
            echo "âŒ Code signature verification failed!"
            echo ""
            echo "== codesign -dvv (signature details) =="
            codesign -dvv "$APP_PATH" 2>&1 || true
            exit 1
          }

          echo ""
          echo "== Signature details =="
          codesign -dvv "$APP_PATH" 2>&1 || true

          echo ""
          echo "âœ… Code signature verified successfully"

      # =============================================================================
      # macOS å…¬è¯ (Notarization)
      # =============================================================================
      - name: Notarize macOS app
        if: matrix.os_name == 'darwin'
        timeout-minutes: 35
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # æ£€æŸ¥å…¬è¯æ‰€éœ€çš„ç¯å¢ƒå˜é‡
          if [ -z "$APPLE_ID" ] || [ -z "$APPLE_ID_PASSWORD" ] || [ -z "$APPLE_TEAM_ID" ]; then
            echo "âš ï¸ Notarization credentials not configured, skipping..."
            exit 0
          fi

          echo "ğŸ” Starting notarization process..."

          # æŸ¥æ‰¾ .app æ–‡ä»¶
          APP_PATH=$(find Frontend/src-tauri/target/${{ matrix.target }}/release/bundle/macos -name "*.app" -type d | head -1)

          if [ -z "$APP_PATH" ]; then
            echo "âŒ No .app bundle found"
            exit 1
          fi

          echo "ğŸ“¦ Found app: $APP_PATH"

          # åˆ›å»º ZIP ç”¨äºå…¬è¯
          ZIP_PATH="${APP_PATH}.zip"
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

          echo " Submitting for notarization..."

          # ä½¿ç”¨ notarytool æäº¤å…¬è¯ï¼Œæ•è·è¾“å‡ºä»¥è·å– submission ID
          NOTARY_OUTPUT=$(mktemp)
          if ! xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 15m 2>&1 | tee "$NOTARY_OUTPUT"; then

            echo "âŒ Notarization failed. Attempting to fetch detailed log..."

            # å°è¯•ä»è¾“å‡ºä¸­æå– submission ID
            SUBMISSION_ID=$(grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' "$NOTARY_OUTPUT" | head -1)

            if [ -n "$SUBMISSION_ID" ]; then
              echo "ğŸ“‹ Fetching log for submission: $SUBMISSION_ID"
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_ID_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi

            rm -f "$NOTARY_OUTPUT" "$ZIP_PATH"
            exit 1
          fi
          rm -f "$NOTARY_OUTPUT"

          echo "ğŸ“ Stapling notarization ticket..."

          # å°†å…¬è¯ç¥¨æ®é™„åŠ åˆ°åº”ç”¨
          xcrun stapler staple "$APP_PATH"

          # éªŒè¯å…¬è¯
          spctl --assess --type execute --verbose "$APP_PATH" || echo "âš ï¸ Gatekeeper check (informational)"

          # æ¸…ç†ä¸´æ—¶ ZIP
          rm -f "$ZIP_PATH"

          echo "âœ… Notarization completed successfully"

      - name: Find build artifacts
        id: artifacts
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          BUNDLE_DIR="Frontend/src-tauri/target/${{ matrix.target }}/release/bundle/${{ matrix.bundle_dir }}"

          echo "ğŸ“‚ Looking for artifacts in: $BUNDLE_DIR"
          ls -la "$BUNDLE_DIR" || echo "Directory not found"

          # æŸ¥æ‰¾æ„å»ºäº§ç‰© (ä½¿ç”¨ matrix.ext æ‰©å±•å)
          FILE=$(find "$BUNDLE_DIR" -name "*.${{ matrix.ext }}" | head -1)
          SIG_FILE="${FILE}.sig"

          if [ -z "$FILE" ]; then
            echo "âŒ No build artifact found with extension .${{ matrix.ext }}"
            exit 1
          fi

          FILENAME=$(basename "$FILE")
          FILESIZE=$(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE")
          # è·¨å¹³å° SHA256 è®¡ç®— (macOS ç”¨ shasum, Linux/Windows Git Bash ç”¨ sha256sum)
          SHA256=$(shasum -a 256 "$FILE" 2>/dev/null | cut -d' ' -f1 || sha256sum "$FILE" | cut -d' ' -f1)

          # è¯»å–ç­¾å (ç­¾åæ˜¯å¤šè¡Œæ–‡æœ¬ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†)
          if [ -f "$SIG_FILE" ]; then
            SIGNATURE=$(cat "$SIG_FILE")
            echo "ğŸ” Signature file found at $SIG_FILE"
          else
            SIGNATURE=""
            echo "âš ï¸ No signature file found at $SIG_FILE"
          fi

          echo "file=$FILE" >> $GITHUB_OUTPUT
          echo "filename=$FILENAME" >> $GITHUB_OUTPUT
          echo "filesize=$FILESIZE" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT

          # å¤šè¡Œç­¾åéœ€è¦ä½¿ç”¨ heredoc è¯­æ³•
          {
            echo "signature<<SIGNATURE_EOF"
            echo "$SIGNATURE"
            echo "SIGNATURE_EOF"
          } >> $GITHUB_OUTPUT

          echo "ğŸ“¦ Found: $FILENAME ($FILESIZE bytes)"
          echo "ğŸ” SHA256: $SHA256"
          echo "ğŸ” Signature length: ${#SIGNATURE}"

      - name: Upload to Release Server
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          FILE="${{ steps.artifacts.outputs.file }}"
          FILENAME="${{ steps.artifacts.outputs.filename }}"

          # é‡å‘½åæ–‡ä»¶ä¸ºæ ‡å‡†æ ¼å¼
          NEW_FILENAME="GEO-SCOPE_${VERSION}_${{ matrix.arch }}.${{ matrix.ext }}"

          # ä¸Šä¼ æ–‡ä»¶åˆ° Release æœåŠ¡å™¨
          echo " Uploading $NEW_FILENAME..."

          UPLOAD_RESPONSE=$(curl -s -X POST \
            "${{ env.RELEASE_SERVER_URL }}/api/uploads/${{ matrix.os_name }}/${{ matrix.arch }}/$NEW_FILENAME" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_API_KEY }}" \
            -H "Content-Type: application/octet-stream" \
            --data-binary "@$FILE")

          echo "Upload response: $UPLOAD_RESPONSE"

          # æå–ä¸Šä¼ åçš„ URL
          DOWNLOAD_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.url // empty')
          if [ -z "$DOWNLOAD_URL" ]; then
            DOWNLOAD_URL="${{ env.RELEASE_SERVER_URL }}/packages/${{ matrix.os_name }}/${{ matrix.arch }}/$NEW_FILENAME"
          fi

          echo "download_url=$DOWNLOAD_URL" >> $GITHUB_ENV

      - name: Register build with Release Server
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"

          # ä½¿ç”¨ heredoc å®‰å…¨è¯»å–å¤šè¡Œç­¾å (é¿å…å¼•å·é—®é¢˜)
          SIGNATURE=$(cat <<'SIGNATURE_HEREDOC'
          ${{ steps.artifacts.outputs.signature }}
          SIGNATURE_HEREDOC
          )
          # ç§»é™¤ heredoc å¼•å…¥çš„é¦–å°¾ç©ºç™½ä½†ä¿ç•™ç­¾åå†…éƒ¨æ¢è¡Œ
          SIGNATURE=$(echo "$SIGNATURE" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          # ä½¿ç”¨ jq å®‰å…¨åœ°æ„å»º JSON (å¤„ç†ç‰¹æ®Šå­—ç¬¦å’Œå¤šè¡Œç­¾å)
          JSON_PAYLOAD=$(jq -n \
            --arg target "${{ matrix.os_name }}" \
            --arg arch "${{ matrix.arch }}" \
            --arg url "${{ env.download_url }}" \
            --arg signature "$SIGNATURE" \
            --argjson size "${{ steps.artifacts.outputs.filesize }}" \
            --arg sha256 "${{ steps.artifacts.outputs.sha256 }}" \
            '{target: $target, arch: $arch, url: $url, signature: $signature, size: $size, sha256: $sha256}')

          echo " Registering build with signature length: ${#SIGNATURE}"

          # æ³¨å†Œæ„å»ºä¿¡æ¯
          curl -s -X POST \
            "${{ env.RELEASE_SERVER_URL }}/api/releases/$VERSION/builds" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_API_KEY }}" \
            -d "$JSON_PAYLOAD"

          echo "âœ… Build registered for ${{ matrix.os_name }}/${{ matrix.arch }}"

      - name: Upload artifact for GitHub Release
        uses: actions/upload-artifact@v4
        with:
          name: GEO-SCOPE-${{ matrix.os_name }}-${{ matrix.arch }}
          path: ${{ steps.artifacts.outputs.file }}
          retention-days: 7

  # =============================================================================
  # å‘å¸ƒé˜¶æ®µ - åˆ›å»º GitHub Release (ä»… tag è§¦å‘)
  # =============================================================================
  github-release:
    needs: [check, prepare, build]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: GEO-SCOPE v${{ needs.prepare.outputs.version }}${{ needs.prepare.outputs.is_prerelease == 'true' && ' (Beta)' || '' }}
          tag_name: ${{ needs.prepare.outputs.tag_name }}
          draft: false
          prerelease: ${{ needs.prepare.outputs.is_prerelease == 'true' }}
          generate_release_notes: true
          files: |
            artifacts/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # =============================================================================
  # é€šçŸ¥é˜¶æ®µ
  # =============================================================================
  notify:
    needs: [check, prepare, build]
    runs-on: ubuntu-latest
    if: always() && needs.check.outputs.should_build == 'true'

    steps:
      - name: Check build status
        run: |
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "âœ… All builds completed successfully!"
            echo "ğŸ“¦ Version: ${{ needs.prepare.outputs.version }}"
            echo "ğŸ”— Release Server: ${{ env.RELEASE_SERVER_URL }}"
          else
            echo "âŒ Some builds failed!"
            exit 1
          fi
